//============================================================================
// Name        : NOVAConfiguration.h
// Copyright   : DataSoft Corporation 2011-2012
//	Nova is free software: you can redistribute it and/or modify
//   it under the terms of the GNU General Public License as published by
//   the Free Software Foundation, either version 3 of the License, or
//   (at your option) any later version.
//
//   Nova is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//   GNU General Public License for more details.
//
//   You should have received a copy of the GNU General Public License
//   along with Nova.  If not, see <http://www.gnu.org/licenses/>.
// Description : Class to load and parse the NOVA configuration file
//============================================================================/*

#include "NovaMessageClient.h"

using namespace std;

namespace Nova
{

	const string NovaMessageClient::prefixes[] = {  };

// Loads the configuration file into the class's state data
	void NovaMessageClient::LoadConfiguration(char const* configFilePath, string module)
	{
		string line;
		string prefix;
		int prefixIndex;

		string use = module.substr(7, (module.length() - 11));

		openlog(use.c_str(), LOG_CONS | LOG_PID | LOG_NDELAY | LOG_PERROR, LOG_AUTHPRIV);

		syslog(SYSL_INFO, "Loading file %s in homepath %s", configFilePath, homeNovaPath.c_str());

		ifstream config(configFilePath);

		//populate the defaultVector. I know it looks a little messy, maybe
		//hard code it somewhere? Just did this so that if we add or remove stuff,
		//we only have to do it here
		for(uint j = 0; j < sizeof(prefixes)/sizeof(prefixes[0]); j++)
		{
			string def;
			switch(j)
			{
				case 0: def = "default";
						break;
				case 1: def = "Config/haystack.config";
						break;
				case 2: def = "7";
						break;
				case 3: def = "3";
						break;
				case 4: def = "0";
						break;
				case 5: def = "../pcapfile";
						break;
				case 6: def = "1";
						break;
				case 7: def = "1";
						break;
				case 8: def = "3";
						break;
				case 9: def = "12024";
						break;
				case 10: def = "3";
						break;
				case 11: def = "0.01";
						break;
				case 12: def = "0";
						break;
				case 13: def = ".5";
						break;
				case 14: def = "Data/data.txt";
						break;
				case 15: def = "3";
						break;
				case 16: def = ".5";
						break;
				case 17: def = "Config/doppelganger.config";
						break;
				case 18: def = "10.0.0.1";
						break;
				case 19: def = "1";
						break;
				case 20: def = "111111111";
						break;
				case 21: def = "Data";
						break;
				default: break;
			}
			defaults.push_back(make_pair(prefixes[j], def));
		}

		if (config.is_open())
		{
			while (config.good())
			{
				getline(config, line);
				prefixIndex = 0;
				prefix = prefixes[prefixIndex];

				// HS_HONEYD_CONFIG
				prefixIndex++;
				prefix = prefixes[prefixIndex];
				if (!line.substr(0, prefix.size()).compare(prefix))
				{
					line = line.substr(prefix.size() + 1, line.size());
					if (line.size() > 0)
					{
						options[prefix].data = homeNovaPath + "/" + line;
						options[prefix].isValid = true;
					}
					continue;
				}
			}
		}
		else
		{
			syslog(SYSL_INFO, "Line: %d No configuration file found.", __LINE__);
		}
		closelog();
	}


	///Checks the optionsMap generated by LoadConfig for any incorrect values;
	///if there are any problems, report to syslog and set option to default
	int NovaMessageClient::SetDefaults()
	{
		openlog(__FUNCTION__, OPEN_SYSL, LOG_AUTHPRIV);

		int out = 0;

		for(uint i = 0; i < options.size() && out < 2; i++)
		{
			//if the option is not valid from LoadConfig, and it is an option that has a default value, assign.
			//anything that has no static default (i.e. something that has a user defined default) will pass
			//on to a given module with isValid being false, and kick out from there. The compare doesn't have to
			//be here until we have a solid foundation determining what will have static defaults and what won't,
			//but I put it in anyways to remind myself when the time comes
			if(!options[prefixes[i]].isValid && defaults[i].second.compare("No") != 0)
			{
				syslog(SYSL_INFO, "Configuration option %s was not set, present, or valid. Setting to default value %s", prefixes[i].c_str(), defaults[i].second.c_str());
				options[prefixes[i]].data = defaults[i].second;
				options[prefixes[i]].isValid = true;
				out = 1;
			}
			if(!options[prefixes[i]].isValid && !defaults[i].second.compare("No"))
			{
				syslog(SYSL_ERR, "The configuration variable %s was not set in the configuration file, and has no default.", prefixes[i].c_str());
				out = 2;
			}
		}

		closelog();
		return out;
	}

	NovaMessageClient::NovaMessageClient()
	{
	}

	NovaMessageClient::~NovaMessageClient()
	{
	}

}

